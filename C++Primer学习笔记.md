# C++ Primer学习笔记

## 第一章 开始

1. return，它结束函数的执行。（P2）

2. 一个流就是一个字符序列，术语“流”想表达的是，随着时间的推移，字符是顺序生成或消耗的。(P5)

3. 写入endl的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中，在调试时添加打印语句，应该保证“一直”刷新流。（P6）

4. 注释界定符中，注释内的每行都以一个星号开头。（P8）

5. 如果注释界定符成对出现，成对的界定符优先。（P9中的练习题）

6.  while(std::cin>>value)中，循环条件实际上检测的时std::cin，当使用一个istream对象作为条件时，其效果是检测流的状态，如果流是有效的，未遇到错误，那么检测成功，当遇到文件结束符，或无效输入的时候，istream对象的状态无效，此时条件为假。（P13）

7. 标准库头文件通常不带后缀。（P17）

8. 对于不属于标准库的头文件，用双引号包围，标准库头文件用<>包围。（P19）

9. C++是一种静态类型语言，它的类型检查发生在编译时。（P28）

## 第二章 变量和基本类型
1. 一个char的空间应确保可以存放基本字符集中任意字符对应的数字值，也就是说一个char的大小和一个机器字节一样。（P30）
2. 可寻址的最小内存块称为“字节”，存储的基本单元成为“字”。（P31）
3. 一般来说，类型float和double分别有7和16个有效位。（P31）
4. 类型unsigned int 可以缩写为unsigned。（P31）
5. 带符号数和无符号数一起运算时，带符号数会自动转化为无符号数。（P35）
6. 默认情况下，十进制字面值是带符号数，八进制和十六进制字面值可能是带符号的也可能是无符号的，十进制字面值的类型是int、long、long long中尺寸最小的那个（前提是这种类型要能容纳下当前的值），short没有对应的字面值，严格来说，十进制字面值不会是负数，对一个形如-42的值来说，那个负号并不在字面值内，它的作用仅是对字面值取负值而已。默认的，浮点型字面值是一个double。（P35）
7. 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符（'\0'），如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。（P36）
8. \x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，如果反斜线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列，而\x要用到后面跟着的所有数字。（P37）
9. 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。（P39）
10. 如果使用列表初始化，但初始值存在丢失信息的风险，编译器将报错。（P39）
11. 函数体之外的变量默认初始化为0，函数体内的内置类型变量将不被初始化。类的对象如果没有显式地初始化，则其值由类确定。（P40）
12. 如果想声明一个变量而非定义它，就在变量名前添加extern，而且不要显式地初始化变量。extern语句如果包含初始值就不再是声明，而变成定义了。在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。（P41）
13. 标识符长度没有限制，对大小写字母敏感，用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。（P42）
14. 建议：当你第一次使用变量时再定义它。（P44）
15. ::reused,显式地访问全局变量。（P44）
16. 引用必须被初始化，一旦初始化完成，将和它的初始值对象一直绑定在一起。为引用赋值，实际上是把值赋给了与引用绑定的对象，获取 引用的值，实际上是获取了与引用绑定的对象的值。（P46）
17. 引用本身不是对象，所以不能定义引用的引用。（P46）
18. 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（P46）
19. 指针本身就是一个对象，因为引用不是一个对象，没有实际地址，所以不能定义指向引用的指针。（P47）
20. NULL是一个预处理变量，这个变量在头文件cstdlib中定义，它的值就是0。（P49）
21. 如果指针的 值是0，条件取false，任何非0指针对应的条件值都是true，如果两个指针存放的地址值相同 ，则它们相等。两个指针相等 ，有三种情况：它们都为空、都指向同一个对象，或者都指向了同一个对象的下一个地址，注意的是，一个指针指向某对象，同时另一个指针指向对象的下一地址，也有可能出现指针相等的情况。（P50）
22. void*存放任意对象的地址，这种指针能做的事有限：和别的指针比较、作为函数的输入或输出、赋给另外一个这种类型的指针，这种指针所指的对象不能直接操作，因为我们不知道这个对象到底是什么类型，也无法确定能在这个对象上做哪些操作。（P50）
23. 存在对指针的引用，面对一条比较复杂的指针或者引用时，从右向左读。（P53）
24. const对象必须初始化，默认情况下，const对象被设定为仅在文件内有效，如果确实需要在文件内共享，不管是声明还是定义都添加extern关键字。（P54）
25. 常量对象只能由常量引用指向，但允许一个常量引用绑定非常量的对象、字面值甚至是一个一般表达式。（P55）
26. 存放常量对象的地址，只能使用指向常量的指针。但允许一个指向常量的指针指向一个非常量对象。（P56）
27. 顶层const表示指针本身是个常量，底层const表示指针指向的对象是一个常量。（P57）
28. 一般来说，如果认定变量是一个常量表达式，那就把它声明成constexpr类型。（P59）
29. 一个constexpr指针的初始值必须是nullptr或者0，或者是存储与某个固定地址中的对象，函数体内定义的变量并非存放在固定地址中，例外是允许函数定义一类有效范围超出本身的变量，这类变量和定义在函数体外的变量一样有固定地址。（P59）
30. 限定符constexpr仅对指针有效，与指针所指的对象无关，是因为constexpr把它所定义的对象置为了顶层const。（P60）
31. 





